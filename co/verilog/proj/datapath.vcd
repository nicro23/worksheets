$date
	Thu Dec 26 12:30:57 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module MIPS_datapath_tb $end
$var reg 2 ! aluop [1:0] $end
$var reg 1 " branch $end
$var reg 1 # clk $end
$var reg 1 $ read_memory $end
$var reg 1 % write_enable $end
$var reg 1 & write_memory $end
$scope module test $end
$var wire 1 " branch $end
$var wire 1 # clk $end
$var wire 1 $ read_memory $end
$var wire 1 % write_enable $end
$var wire 1 & write_memory $end
$var wire 1 ' zero $end
$var wire 32 ( write_data [31:0] $end
$var wire 32 ) signextend [31:0] $end
$var wire 5 * shamt [4:0] $end
$var wire 32 + rt_data [31:0] $end
$var wire 5 , rt_a [4:0] $end
$var wire 32 - rs_data [31:0] $end
$var wire 5 . rs_a [4:0] $end
$var wire 32 / read_data [31:0] $end
$var wire 32 0 rd_data [31:0] $end
$var wire 5 1 rd_a [4:0] $end
$var wire 32 2 instruction [31:0] $end
$var wire 6 3 funct [5:0] $end
$var wire 32 4 aluout [31:0] $end
$var wire 6 5 aluop [5:0] $end
$var wire 32 6 PC [31:0] $end
$var wire 32 7 Mem_address [31:0] $end
$var wire 32 8 BTA [31:0] $end
$var wire 32 9 B [31:0] $end
$var wire 32 : A [31:0] $end
$var reg 1 ; PC_init $end
$var reg 3 < state [2:0] $end
$scope module ALU $end
$var wire 32 = a [31:0] $end
$var wire 32 > b [31:0] $end
$var wire 6 ? func_code [5:0] $end
$var wire 5 @ shamt [4:0] $end
$var wire 1 ' zero $end
$var reg 32 A c [31:0] $end
$upscope $end
$scope module DM $end
$var wire 32 B Instruction_Address [31:0] $end
$var wire 1 $ Read_M $end
$var wire 32 C W_Data [31:0] $end
$var wire 1 & Write_M $end
$var wire 1 # clk $end
$var reg 32 D R_Data [31:0] $end
$scope begin $ivl_for_loop2 $end
$var integer 32 E k [31:0] $end
$upscope $end
$upscope $end
$scope module IM $end
$var wire 32 F Instruction_Address [31:0] $end
$var reg 32 G Instruction [31:0] $end
$scope begin $ivl_for_loop0 $end
$var integer 32 H k [31:0] $end
$upscope $end
$upscope $end
$scope module RF $end
$var wire 1 # clk $end
$var wire 5 I rd_address [4:0] $end
$var wire 32 J rd_data [31:0] $end
$var wire 5 K rs_address [4:0] $end
$var wire 32 L rs_data [31:0] $end
$var wire 5 M rt_address [4:0] $end
$var wire 32 N rt_data [31:0] $end
$var wire 1 % write_enable $end
$scope begin $ivl_for_loop1 $end
$var integer 32 O i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b100000 O
b0 N
b1101 M
b100 L
b1011 K
bx J
b1101 I
b10000000 H
b10001101011011010000000000000000 G
b0 F
b1000000000 E
bx D
bx C
bx B
bx A
b0 @
b100000 ?
bx >
bx =
b1 <
0;
bx :
bx 9
bxzz 8
bx 7
b0 6
b100011 5
bx 4
b100000 3
b10001101011011010000000000000000 2
b1101 1
bx 0
bx /
b1011 .
b100 -
b1101 ,
b0 +
b0 *
b0 )
bx (
x'
0&
1%
1$
1#
0"
b0 !
$end
#1
bx +
bx N
0'
b100 4
b100 A
b100 :
b100 =
b0 9
b0 >
b0 8
b10 <
1#
#2
b100 7
b100 B
b100 (
b100 C
b11 <
1#
#3
b100 <
b0 /
b0 D
1#
#4
